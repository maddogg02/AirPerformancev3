import { useState, useEffect } from "react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent } from "@/components/ui/card";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { ProButton } from "@/components/ui/pro-button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Search, Filter, FileDown, Calendar, Edit2, Trash2, MessageSquare, ChevronDown, ChevronRight, FileText, Plus, Sparkles } from "lucide-react";
import { cn } from "@/lib/utils";
import type { AIREntry, PerformanceCategory } from "@/types";
import { usePerformanceEntries } from "@/hooks/usePerformanceEntries";
import { useStatements } from "@/hooks/useStatements";
import { getStatementsByEntryId, getStatements, updateStatement, deleteStatement, type Statement } from "@/lib/statements";
import { useToast } from "@/hooks/use-toast";
import { CreateStatementsScreen } from "./CreateStatementsScreen";

const categories: PerformanceCategory[] = ['Mission Execution', 'Leading People', 'Improving the Unit', 'Managing Resources'];

interface LibraryScreenProps {
  initialFilter?: string;
}

export function LibraryScreen({ initialFilter }: LibraryScreenProps) {
  const { entries, isLoading, updateEntry, removeEntry } = usePerformanceEntries();
  const { addStatement } = useStatements();
  const { toast } = useToast();
  const [activeTab, setActiveTab] = useState("entries");
  const [searchQuery, setSearchQuery] = useState("");
  const [statementSearchQuery, setStatementSearchQuery] = useState("");
  const [selectedCategory, setSelectedCategory] = useState<string>("all");
  const [editingEntry, setEditingEntry] = useState<AIREntry | null>(null);
  const [editAction, setEditAction] = useState("");
  const [editImpact, setEditImpact] = useState("");
  const [editResult, setEditResult] = useState("");
  const [deletingEntryId, setDeletingEntryId] = useState<string | null>(null);
  const [entryStatements, setEntryStatements] = useState<Record<string, Statement[]>>({});
  const [allStatements, setAllStatements] = useState<Statement[]>([]);
  const [statementsWithEntryData, setStatementsWithEntryData] = useState<(Statement & { entryCategory?: string; entryCreatedAt?: Date })[]>([]);
  const [selectedStatementCategory, setSelectedStatementCategory] = useState<string>("all");
  const [expandedEntries, setExpandedEntries] = useState<Set<string>>(new Set());
  const [editingStatement, setEditingStatement] = useState<Statement | null>(null);
  const [editStatementText, setEditStatementText] = useState("");
  const [writingStatementForEntry, setWritingStatementForEntry] = useState<string | null>(null);
  const [newStatementText, setNewStatementText] = useState("");
  
  // New state for streamlined statement generation
  const [showCreateStatements, setShowCreateStatements] = useState(false);
  const [selectedEntryForStatement, setSelectedEntryForStatement] = useState<AIREntry | null>(null);

  // Filter entries based on search and category
  const filteredEntries = entries.filter(entry => {
    const matchesSearch = !searchQuery || 
      entry.action.toLowerCase().includes(searchQuery.toLowerCase()) ||
      entry.impact.toLowerCase().includes(searchQuery.toLowerCase()) ||
      entry.result.toLowerCase().includes(searchQuery.toLowerCase());
      
    const matchesCategory = selectedCategory === "all" || entry.category === selectedCategory;
    
    return matchesSearch && matchesCategory;
  });

  // Filter statements based on search and category
  const filteredStatements = statementsWithEntryData.filter(statement => {
    const matchesSearch = !statementSearchQuery || 
      statement.statement_text.toLowerCase().includes(statementSearchQuery.toLowerCase());
    const matchesCategory = selectedStatementCategory === "all" || statement.entryCategory === selectedStatementCategory;
    return matchesSearch && matchesCategory;
  });

  // Load statements for entries and all statements
  useEffect(() => {
    const loadStatements = async () => {
      if (entries.length > 0) {
        const statementsMap: Record<string, Statement[]> = {};
        
        for (const entry of entries) {
          try {
            const statements = await getStatementsByEntryId(entry.id);
            if (statements.length > 0) {
              statementsMap[entry.id] = statements;
            }
          } catch (error) {
            console.error(`Failed to load statements for entry ${entry.id}:`, error);
          }
        }
        
        setEntryStatements(statementsMap);
      }
    };

    const loadAllStatements = async () => {
      try {
        const statements = await getStatements();
        setAllStatements(statements);
        
        // Enhance statements with entry data
        const enhancedStatements = statements.map(statement => {
          const relatedEntry = entries.find(entry => entry.id === statement.performance_entry_id);
          return {
            ...statement,
            entryCategory: relatedEntry?.category,
            entryCreatedAt: relatedEntry?.createdAt
          };
        });
        
        setStatementsWithEntryData(enhancedStatements);
      } catch (error) {
        console.error('Failed to load all statements:', error);
      }
    };

    loadStatements();
    loadAllStatements();
  }, [entries]);

  const handleEditStatement = (statement: Statement) => {
    setEditingStatement(statement);
    setEditStatementText(statement.statement_text);
  };

  const handleSaveStatementEdit = async () => {
    if (!editingStatement) return;
    
    try {
      const updatedStatement = await updateStatement(editingStatement.id, editStatementText);
      if (updatedStatement) {
        // Update local state for entry statements
        setEntryStatements(prev => ({
          ...prev,
          [editingStatement.performance_entry_id]: prev[editingStatement.performance_entry_id]?.map(s => 
            s.id === editingStatement.id ? updatedStatement : s
          ) || []
        }));
        
        // Update all statements list
        setAllStatements(prev => prev.map(s => 
          s.id === editingStatement.id ? updatedStatement : s
        ));
        
        // Update enhanced statements list
        setStatementsWithEntryData(prev => prev.map(s => 
          s.id === editingStatement.id ? { ...updatedStatement, entryCategory: s.entryCategory, entryCreatedAt: s.entryCreatedAt } : s
        ));
        
        toast({
          title: "Draft Updated",
          description: "Draft updated successfully"
        });
        setEditingStatement(null);
        setEditStatementText("");
      }
    } catch (error) {
      toast({
        title: "Update Failed",
        description: "Failed to update draft",
        variant: "destructive"
      });
    }
  };

  const handleDeleteStatement = async (statementId: string, entryId?: string) => {
    try {
      await deleteStatement(statementId);
      
      toast({
        title: "Draft Deleted",
        description: "Draft removed successfully"
      });
      
      // Update local state for entry statements if entryId provided
      if (entryId) {
        setEntryStatements(prev => ({
          ...prev,
          [entryId]: (prev[entryId] || []).filter(s => s.id !== statementId)
        }));
      }
      
      // Update all statements list
      setAllStatements(prev => prev.filter(s => s.id !== statementId));
      
      // Update enhanced statements list
      setStatementsWithEntryData(prev => prev.filter(s => s.id !== statementId));
      
    } catch (error) {
      toast({
        title: "Delete Failed",
        description: "Failed to delete draft",
        variant: "destructive"
      });
    }
  };

  const toggleEntryExpansion = (entryId: string) => {
    setExpandedEntries(prev => {
      const newSet = new Set(prev);
      if (newSet.has(entryId)) {
        newSet.delete(entryId);
      } else {
        newSet.add(entryId);
      }
      return newSet;
    });
  };

  const formatDate = (date: Date) => {
    return date.toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric',
      year: '2-digit'
    });
  };

  const handleEditEntry = (entry: AIREntry) => {
    setEditingEntry(entry);
    setEditAction(entry.action);
    setEditImpact(entry.impact);
    setEditResult(entry.result);
  };

  const handleSaveEdit = async () => {
    if (!editingEntry) return;
    
    const success = await updateEntry(editingEntry.id, {
      action: editAction,
      impact: editImpact,
      result: editResult,
    });

    if (success) {
      toast({
        title: "Entry Updated",
        description: "Your changes have been saved"
      });
      setEditingEntry(null);
      setEditAction("");
      setEditImpact("");
      setEditResult("");
    }
  };

  const handleDeleteEntry = async (entryId: string) => {
    const success = await removeEntry(entryId);
    if (success) {
      toast({
        title: "Entry Deleted", 
        description: "Performance entry has been removed"
      });
      setDeletingEntryId(null);
    }
  };

  const handleAddStatement = async (entryId: string) => {
    if (!newStatementText.trim()) {
      toast({
        title: "Empty Draft",
        description: "Please enter a draft before saving.",
        variant: "destructive"
      });
      return;
    }

    const success = await addStatement(entryId, newStatementText.trim());
    if (success) {
      // Refresh statements for this entry
      try {
        const updatedStatements = await getStatementsByEntryId(entryId);
        setEntryStatements(prev => ({
          ...prev,
          [entryId]: updatedStatements
        }));
        
        // Also update all statements list
        const allStatementsData = await getStatements();
        setAllStatements(allStatementsData);
        
        // Update enhanced statements
        const enhancedStatements = allStatementsData.map(statement => {
          const relatedEntry = entries.find(entry => entry.id === statement.performance_entry_id);
          return {
            ...statement,
            entryCategory: relatedEntry?.category,
            entryCreatedAt: relatedEntry?.createdAt
          };
        });
        setStatementsWithEntryData(enhancedStatements);
        
        // Clear the input and close writing mode
        setNewStatementText("");
        setWritingStatementForEntry(null);
        
        toast({
          title: "Draft Saved",
          description: "Draft has been saved to this entry"
        });
      } catch (error) {
        console.error('Error refreshing statements:', error);
      }
    }
  };

  // New streamlined handler for generating statements directly from quick wins
  const handleGenerateStatement = (entry: AIREntry) => {
    setSelectedEntryForStatement(entry);
    setShowCreateStatements(true);
  };

  const handleCloseCreateStatements = async () => {
    setShowCreateStatements(false);
    setSelectedEntryForStatement(null);
    
    // Refresh statements after creation
    if (entries.length > 0) {
      const statementsMap: Record<string, Statement[]> = {};
      
      for (const entry of entries) {
        try {
          const statements = await getStatementsByEntryId(entry.id);
          if (statements.length > 0) {
            statementsMap[entry.id] = statements;
          }
        } catch (error) {
          console.error(`Failed to load statements for entry ${entry.id}:`, error);
        }
      }
      
      setEntryStatements(statementsMap);
      
      // Also refresh all statements
      try {
        const statements = await getStatements();
        setAllStatements(statements);
        
        const enhancedStatements = statements.map(statement => {
          const relatedEntry = entries.find(entry => entry.id === statement.performance_entry_id);
          return {
            ...statement,
            entryCategory: relatedEntry?.category,
            entryCreatedAt: relatedEntry?.createdAt
          };
        });
        
        setStatementsWithEntryData(enhancedStatements);
      } catch (error) {
        console.error('Failed to load all statements:', error);
      }
    }
  };

  return (
    <div className="min-h-screen bg-background pb-20 px-4 pt-6">
      <div className="max-w-md mx-auto space-y-6">
        {/* Header */}
        <div className="space-y-4">
          <div className="relative text-center">
            <h1 className="text-2xl font-bold text-foreground">Performance Library</h1>
            <div className="absolute right-0 top-0">
              <ProButton />
            </div>
          </div>
          
          {/* Tabs */}
          <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
            <TabsList className="grid w-full grid-cols-3">
              <TabsTrigger value="entries" className="flex items-center gap-2">
                <FileDown className="w-4 h-4" />
                Entries
              </TabsTrigger>
              <TabsTrigger value="drafts" className="flex items-center gap-2">
                <FileText className="w-4 h-4" />
                Drafts
              </TabsTrigger>
              <TabsTrigger value="statements" className="flex items-center gap-2">
                <MessageSquare className="w-4 h-4" />
                Statements
              </TabsTrigger>
            </TabsList>
            
            <TabsContent value="entries" className="space-y-4 mt-4">
              {/* Search Bar */}
              <div className="relative">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground w-4 h-4" />
                <Input
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  placeholder="Search your wins..."
                  className="pl-10"
                />
              </div>

              {/* Filters */}
              <div className="flex gap-2">
                <Select value={selectedCategory} onValueChange={setSelectedCategory}>
                  <SelectTrigger className="flex-1">
                    <div className="flex items-center gap-2">
                      <Filter className="w-4 h-4" />
                      <SelectValue />
                    </div>
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="all">All Categories</SelectItem>
                    {categories.map((category) => (
                      <SelectItem key={category} value={category}>
                        {category}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              {/* Results Count */}
              <div className="text-sm text-muted-foreground text-center">
                {filteredEntries.length} {filteredEntries.length === 1 ? 'entry' : 'entries'}
              </div>

              {/* Entries List */}
              {isLoading ? (
                <div className="text-center py-8 space-y-2">
                  <p className="text-muted-foreground">Loading your performance entries...</p>
                </div>
              ) : (
                <div className="space-y-3">
                  {filteredEntries.map((entry) => {
                    const hasStatements = entryStatements[entry.id] && entryStatements[entry.id].length > 0;
                    const isExpanded = expandedEntries.has(entry.id);
                    
                    return (
                      <Card 
                        key={entry.id}
                        className="transition-base hover:shadow-md"
                      >
                        <CardContent className="pt-4">
                          <div className="space-y-3">
                            {/* Header */}
                            <div className="flex items-start justify-between gap-2">
                              <div className="flex items-center gap-2">
                                <Badge variant="secondary" className="text-xs">
                                  {entry.category}
                                </Badge>
                                {hasStatements && (
                                  <Badge variant="outline" className="text-xs">
                                    {entryStatements[entry.id].length} draft{entryStatements[entry.id].length !== 1 ? 's' : ''}
                                  </Badge>
                                )}
                              </div>
                              <div className="flex items-center gap-2 text-xs text-muted-foreground">
                                <Calendar className="w-3 h-3" />
                                {formatDate(entry.createdAt)}
                              </div>
                            </div>

                            {/* Full Performance Bullet */}
                            <div className="space-y-2">
                              <div>
                                <p className="text-xs text-muted-foreground font-medium">ACTION</p>
                                <p className="text-sm text-foreground">
                                  {entry.action}
                                </p>
                              </div>
                              <div>
                                <p className="text-xs text-muted-foreground font-medium">IMPACT</p>
                                <p className="text-sm text-foreground">
                                  {entry.impact}
                                </p>
                              </div>
                              <div>
                                <p className="text-xs text-muted-foreground font-medium">RESULT</p>
                                <p className="text-sm text-foreground">
                                  {entry.result}
                                </p>
                              </div>
                            </div>

                            {/* Actions */}
                            <div className="flex items-center justify-between">
                              <div className="flex gap-2">
                                <Button
                                  variant="ghost"
                                  size="sm"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    handleEditEntry(entry);
                                  }}
                                  className="h-8 px-2 text-xs"
                                >
                                  <Edit2 className="w-4 h-4" />
                                  Edit
                                </Button>
                                <Button
                                  variant="ghost"
                                  size="sm"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    setDeletingEntryId(entry.id);
                                  }}
                                  className="text-destructive hover:text-destructive"
                                >
                                  <Trash2 className="w-4 h-4" />
                                  Delete
                                </Button>
                              </div>
                            </div>

                            {/* Primary Action - Generate Statement (New Streamlined Flow) */}
                            <div className="pt-2">
                              <Button
                                variant="default"
                                size="sm"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  handleGenerateStatement(entry);
                                }}
                                className="w-full gap-2 bg-primary hover:bg-primary/90"
                              >
                                <Sparkles className="w-4 h-4" />
                                🚀 Generate Statement from This Win
                              </Button>
                            </div>

                            {/* Secondary Option - Manual Drafts (De-emphasized) */}
                            <div className="space-y-2 pt-3 border-t border-muted/30">
                              <details className="group">
                                <summary className="cursor-pointer text-xs text-muted-foreground hover:text-foreground transition-colors flex items-center gap-2">
                                  <ChevronRight className="w-3 h-3 group-open:rotate-90 transition-transform" />
                                  <span>Or manually write a draft</span>
                                  {hasStatements && (
                                    <Badge variant="outline" className="text-xs">
                                      {entryStatements[entry.id].length} saved
                                    </Badge>
                                  )}
                                </summary>
                                
                                <div className="mt-2 space-y-2">
                                  {hasStatements && (
                                    <div className="space-y-2">
                                      {entryStatements[entry.id].map((statement) => (
                                        <div key={statement.id} className="p-2 border rounded text-xs bg-muted/10">
                                          <div className="flex items-start justify-between gap-2 mb-1">
                                            <p className="text-xs text-muted-foreground">
                                              {formatDate(new Date(statement.created_at))}
                                            </p>
                                            <div className="flex gap-1">
                                              <Button
                                                variant="ghost"
                                                size="sm"
                                                onClick={(e) => {
                                                  e.stopPropagation();
                                                  handleEditStatement(statement);
                                                }}
                                                className="h-6 w-6 p-0"
                                              >
                                                <Edit2 className="w-3 h-3" />
                                              </Button>
                                              <Button
                                                variant="ghost"
                                                size="sm"
                                                onClick={(e) => {
                                                  e.stopPropagation();
                                                  handleDeleteStatement(statement.id, entry.id);
                                                }}
                                                className="h-6 w-6 p-0 text-destructive hover:text-destructive"
                                              >
                                                <Trash2 className="w-3 h-3" />
                                              </Button>
                                            </div>
                                          </div>
                                          <p className="text-xs leading-relaxed">{statement.statement_text}</p>
                                        </div>
                                      ))}
                                    </div>
                                  )}

                                  {/* Add new draft to this entry */}
                                  {writingStatementForEntry === entry.id ? (
                                    <div className="space-y-2 p-2 border rounded-lg bg-muted/5">
                                      <Textarea
                                        value={newStatementText}
                                        onChange={(e) => setNewStatementText(e.target.value)}
                                        placeholder="Write a draft statement manually..."
                                        className="min-h-[60px] text-xs"
                                      />
                                      <div className="flex gap-2">
                                        <Button
                                          size="sm"
                                          onClick={() => handleAddStatement(entry.id)}
                                          disabled={!newStatementText.trim()}
                                          className="flex-1 h-7 text-xs"
                                        >
                                          Save Draft
                                        </Button>
                                        <Button
                                          size="sm"
                                          variant="outline"
                                          onClick={() => {
                                            setWritingStatementForEntry(null);
                                            setNewStatementText("");
                                          }}
                                          className="flex-1 h-7 text-xs"
                                        >
                                          Cancel
                                        </Button>
                                      </div>
                                    </div>
                                  ) : (
                                    <Button
                                      variant="ghost"
                                      size="sm"
                                      onClick={(e) => {
                                        e.stopPropagation();
                                        setWritingStatementForEntry(entry.id);
                                      }}
                                      className="w-full text-xs h-7 justify-start text-muted-foreground"
                                    >
                                      <Plus className="w-3 h-3 mr-1" />
                                      Add manual draft
                                    </Button>
                                  )}
                                </div>
                              </details>
                            </div>
                          </div>
                        </CardContent>
                      </Card>
                    );
                  })}
                </div>
              )}
            </TabsContent>

            {/* Drafts Tab - Show All Statements */}
            <TabsContent value="drafts" className="space-y-4 mt-4">
              {/* Search Bar */}
              <div className="relative">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground w-4 h-4" />
                <Input
                  value={statementSearchQuery}
                  onChange={(e) => setStatementSearchQuery(e.target.value)}
                  placeholder="Search your drafts..."
                  className="pl-10"
                />
              </div>

              {/* Category Filter */}
              <div className="flex gap-2">
                <Select value={selectedStatementCategory} onValueChange={setSelectedStatementCategory}>
                  <SelectTrigger className="flex-1">
                    <div className="flex items-center gap-2">
                      <Filter className="w-4 h-4" />
                      <SelectValue />
                    </div>
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="all">All Categories</SelectItem>
                    {categories.map((category) => (
                      <SelectItem key={category} value={category}>
                        {category}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              {/* Results Count */}
              <div className="text-sm text-muted-foreground text-center">
                {filteredStatements.length} {filteredStatements.length === 1 ? 'draft' : 'drafts'}
              </div>

              {/* Statements List */}
              <div className="space-y-3">
                {filteredStatements.map((statement) => (
                  <Card key={statement.id} className="transition-base hover:shadow-md">
                    <CardContent className="pt-4">
                      <div className="space-y-3">
                        {/* Header */}
                        <div className="flex items-start justify-between gap-2">
                          <div className="flex items-center gap-2">
                            {statement.entryCategory && (
                              <Badge variant="secondary" className="text-xs">
                                {statement.entryCategory}
                              </Badge>
                            )}
                          </div>
                          <div className="flex items-center gap-2 text-xs text-muted-foreground">
                            <Calendar className="w-3 h-3" />
                            {formatDate(new Date(statement.created_at))}
                          </div>
                        </div>

                        {/* Statement Text */}
                        <p className="text-sm text-foreground leading-relaxed">
                          {statement.statement_text}
                        </p>

                        {/* Actions */}
                        <div className="flex gap-2 pt-2">
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => handleEditStatement(statement)}
                            className="h-8 px-2 text-xs"
                          >
                            <Edit2 className="w-3 h-3" />
                            Edit
                          </Button>
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => handleDeleteStatement(statement.id)}
                            className="h-8 px-2 text-xs text-destructive hover:text-destructive"
                          >
                            <Trash2 className="w-3 h-3" />
                            Delete
                          </Button>
                        </div>
                      </div>
                    </CardContent>
                  </Card>
                ))}
              </div>
            </TabsContent>

            {/* Statements Tab - Placeholder for future features */}
            <TabsContent value="statements" className="space-y-4 mt-4">
              <div className="text-center py-8 space-y-4">
                <MessageSquare className="w-16 h-16 mx-auto text-muted-foreground" />
                <div className="space-y-2">
                  <h3 className="text-lg font-semibold">Final Statements</h3>
                  <p className="text-sm text-muted-foreground">
                    This section will contain your finalized performance statements ready for EPRs/OPRs.
                  </p>
                </div>
              </div>
            </TabsContent>
          </Tabs>
        </div>
      </div>

      {/* Edit Entry Dialog */}
      <Dialog open={!!editingEntry} onOpenChange={(open) => !open && setEditingEntry(null)}>
        <DialogContent className="max-w-md">
          <DialogHeader>
            <DialogTitle>Edit Performance Entry</DialogTitle>
          </DialogHeader>
          <div className="space-y-4">
            <div>
              <Label htmlFor="editAction">Action</Label>
              <Textarea
                id="editAction"
                value={editAction}
                onChange={(e) => setEditAction(e.target.value)}
                placeholder="What was the action taken?"
                className="mt-1"
                rows={3}
              />
            </div>
            <div>
              <Label htmlFor="editImpact">Impact</Label>
              <Textarea
                id="editImpact" 
                value={editImpact}
                onChange={(e) => setEditImpact(e.target.value)}
                placeholder="What was the impact or result?"
                className="mt-1"
                rows={3}
              />
            </div>
            <div>
              <Label htmlFor="editResult">Result</Label>
              <Textarea
                id="editResult"
                value={editResult}
                onChange={(e) => setEditResult(e.target.value)}
                placeholder="What was the final outcome?"
                className="mt-1"
                rows={3}
              />
            </div>
            <div className="flex gap-2 pt-4">
              <Button 
                variant="outline" 
                onClick={() => setEditingEntry(null)}
                className="flex-1"
              >
                Cancel
              </Button>
              <Button 
                onClick={handleSaveEdit}
                className="flex-1"
                disabled={!editAction.trim() || !editImpact.trim() || !editResult.trim()}
              >
                Save Changes
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>

      {/* Edit Statement Dialog */}
      {editingStatement && (
        <Dialog open={!!editingStatement} onOpenChange={() => setEditingStatement(null)}>
          <DialogContent className="max-w-md">
            <DialogHeader>
              <DialogTitle>Edit Draft Statement</DialogTitle>
            </DialogHeader>
            <div className="space-y-4">
              <div>
                <Label htmlFor="editStatement">Statement Text</Label>
                <Textarea
                  id="editStatement"
                  value={editStatementText}
                  onChange={(e) => setEditStatementText(e.target.value)}
                  placeholder="Edit your draft..."
                  className="min-h-[120px]"
                />
              </div>
              <div className="flex gap-2 pt-4">
                <Button 
                  variant="outline" 
                  onClick={() => setEditingStatement(null)}
                  className="flex-1"
                >
                  Cancel
                </Button>
                <Button 
                  onClick={handleSaveStatementEdit}
                  className="flex-1"
                  disabled={!editStatementText.trim()}
                >
                  Save Changes
                </Button>
              </div>
            </div>
          </DialogContent>
        </Dialog>
      )}

      {/* Delete Confirmation Dialog */}
      <Dialog open={!!deletingEntryId} onOpenChange={() => setDeletingEntryId(null)}>
        <DialogContent className="max-w-md">
          <DialogHeader>
            <DialogTitle>Delete Performance Entry</DialogTitle>
          </DialogHeader>
          <div className="space-y-4">
            <p className="text-sm text-muted-foreground">
              Are you sure you want to delete this performance entry? This action cannot be undone.
            </p>
            <div className="flex gap-2 pt-4">
              <Button 
                variant="destructive" 
                onClick={() => deletingEntryId && handleDeleteEntry(deletingEntryId)}
                className="flex-1"
              >
                Delete Entry
              </Button>
              <Button variant="outline" onClick={() => setDeletingEntryId(null)}>
                Cancel
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>

      {/* Streamlined Statement Generation - Direct from Quick Wins */}
      {showCreateStatements && selectedEntryForStatement && (
        <div className="fixed inset-0 z-50 bg-background">
          <CreateStatementsScreen 
            initialStatements={[{
              id: `temp-${Date.now()}`,
              statement: `${selectedEntryForStatement.action} ${selectedEntryForStatement.impact} ${selectedEntryForStatement.result}`,
              score: 0,
              isEditing: true,
              editedText: `${selectedEntryForStatement.action} ${selectedEntryForStatement.impact} ${selectedEntryForStatement.result}`,
              characterCount: (`${selectedEntryForStatement.action} ${selectedEntryForStatement.impact} ${selectedEntryForStatement.result}`).length,
              askBacks: null,
              aiFeedback: null
            }]}
            onClose={handleCloseCreateStatements}
          />
        </div>
      )}
    </div>
  );
}